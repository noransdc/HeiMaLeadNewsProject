# HeiMaLeadNewsProject







### ✅ Step 1：事件表（event_outbox）

**目标：表建好，能插数据**

你现在只需要做到：

- 表结构确定
- 能在 user-service 里插入一条事件
- 不发送 MQ 也没关系

**完成标准：**

- 插一条收藏，对应多一条 event_outbox 记录

------

### ✅ Step 2：添加收藏接口（user-service）

**目标：事实正确**

接口流程只做这两件事：

1. 写 `user_collection`（唯一约束）
2. 写 `event_outbox`

**完成标准：**

- 重复收藏不会插两次
- event_outbox event_id 唯一

------

### ⏸️ 暂时不做的事（非常重要）

这一步**不要**做：

- Kafka
- 重试
- Streams
- Redis

**忍住。**

------

### ✅ Step 3：最简单的事件发送（可选）

等你 Step 1 / 2 稳了，再做：

- 一个定时任务
- 扫描 status=NEW
- 发 Kafka
- 标记 SENT

**完成标准：**

- Kafka topic 能看到消息

------

### ✅ Step 4：article-core 消费 + 计数

**目标：派生数据正确**

先用 **普通 MQ 消费**：

1. 插 consume_log
2. collection_count +1

**完成标准：**

- 重放消息不会重复加

------

### ⏸️ 仍然不做的事

- Kafka Streams
- 热度公式
- Redis 热榜

------

### ✅ Step 5：Kafka Streams（最后加）

只在前面都稳定后：

- 把 MQ 消费换成 Streams
- 或并行一条 Streams 链路

------

### ✅ Step 6：Redis 热榜（收尾）

- ZSET
- TopN
- 前端读





event_outbox

outbox 表通过状态字段控制事件发送流程，区分未发送、已发送和失败状态，并结合重试次数保证消息的可靠投递，避免业务事务和消息发送的强耦合。

outbox 表通过 SENDING 状态和条件更新实现多实例下的事件抢占，避免重复发送，相当于用数据库行锁实现了一层轻量级分布式互斥。



文章表作为业务事实表，ID 设计以当前数据库性能和开发效率为优先；
 事件表作为跨领域的基础设施表，需要兼容不同聚合的标识形式，因此在设计阶段即采用字符串类型以保证长期演进能力。



用户收藏表只保存当前有效关系，取消收藏采用物理删除；
 用户行为历史通过事件系统记录并驱动统计，避免在关系表中做逻辑删除导致表膨胀。
