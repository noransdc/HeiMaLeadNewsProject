修改发布时间的调度规则

# 一、修改发布时间的调度规则（设计文档版）

## 1. 业务背景

文章支持作者修改发布时间。
 系统采用独立的 **Schedule 服务** 统一负责定时任务调度，文章核心服务仅负责业务状态流转。

发布任务以 `(articleId, ARTICLE_PUBLISH)` 作为**唯一调度单元**。

------

## 2. 事件触发方式

当作者修改发布时间时：

- Article 服务更新文章表中的 `publish_time`
- 向 Schedule 服务发送 **“发布时间变更事件”**
  - 当前可采用同步 RPC
  - 架构上预留为 MQ（Kafka / RocketMQ）事件，便于解耦与扩展

该事件语义为：

> **未来调度意图发生变化，而不是撤销已发生的行为**

------

## 3. 核心调度规则（非常关键）

Schedule 服务在处理发布时间变更时，遵循以下规则：

### 规则一：优先 UPDATE，避免不必要的重建

对于发布任务：

- 若任务状态为 `INIT` 或 `FAIL`（且 retry_count < max_retry）
  - 直接 **UPDATE execute_time**
  - 任务 ID 不变，语义连续

```
能改就改（UPDATE）
```

------

### 规则二：RUNNING 状态禁止 UPDATE

若发布任务已进入 `RUNNING` 状态：

- 说明调度线程可能已经开始执行
- UPDATE 存在并发竞态风险
- 不尝试修改 execute_time

此时采取：

- 将旧任务标记为 `CANCELLED`
- 新建一条发布任务，使用新的 `execute_time`

```
不可安全修改 → CANCEL + INSERT
```

------

### 规则三：SUCCESS 状态禁止调整

若发布任务状态为 `SUCCESS`：

- 表示文章已成功发布
- 发布时间修改不再生效
- 调度系统不做任何处理

------

## 4. 并发兜底规则（非常重要）

在并发场景下，可能出现以下情况：

- Schedule 服务先 `SELECT` 到任务为 `INIT`
- 在 `UPDATE` 前，被其他线程改为 `RUNNING`
- `UPDATE … WHERE status = INIT` 影响行数为 0

此时规则是：

> **UPDATE 失败 ≠ 操作结束，而是需要重新决策**

处理流程：

1. 尝试 UPDATE（乐观路径）
2. 若 `affected_rows == 0`
3. 重新查询当前任务状态
4. 根据最新状态：
   - `RUNNING` → CANCEL + INSERT
   - `SUCCESS` → 忽略
   - `CANCELLED / 不存在` → INSERT

------

## 5. 为什么允许 RUNNING 任务继续执行

当任务已进入 RUNNING 状态时：

- 发布请求可能已经发送到文章服务
- 调度系统不会尝试撤销已发出的 RPC

原因：

- 时间不可逆
- 调度层不负责回滚已发生行为
- 最终是否发布，由文章服务的**状态机 + 幂等逻辑**决定

即使新旧任务都尝试执行：

- Article 状态机只允许一次 `AUDIT_SUCCESS → PUBLISHED`
- 多次调用不会影响最终业务结果

------

## 6. 核心设计原则总结（一句话版）

> **调度系统负责“何时尝试执行”，
>  业务系统负责“是否真的生效”。**

------

# 二、面试如何讲（3 分钟口述版）

你在面试中可以这样讲，逻辑非常清晰，也非常“工程味”。

------

### 1️⃣ 先给背景（30 秒）

> 我们把审核和发布的定时任务统一放在一个独立的 Schedule 服务中，
>  文章核心服务只负责业务状态机，不做任何时间调度。

发布任务以 `(articleId, ARTICLE_PUBLISH)` 作为唯一调度单元。

------

### 2️⃣ 说明发布时间是“可变业务”（30 秒）

> 发布时间是作者可以修改的业务属性，所以发布任务必须支持被调整，
>  而不是简单地新建任务，否则会出现重复发布和脏任务历史。

------

### 3️⃣ 讲清 UPDATE vs 重建规则（1 分钟，重点）

> 我们的规则是：
>  **能安全 UPDATE 的就 UPDATE，不安全的才重建。**

- INIT / FAIL：直接更新 execute_time
- RUNNING：取消旧任务，新建任务
- SUCCESS：不允许修改

RUNNING 状态下不 UPDATE，是为了避免并发竞态。

------

### 4️⃣ 并发兜底（30 秒）

> 即使 UPDATE 失败，比如任务刚好被其他线程改成 RUNNING，
>  我们会重新查状态，再决定是重建还是忽略，保证发布时间修改不会被吞掉。

------

### 5️⃣ 最后强调幂等与最终一致性（30 秒）

> 即便 RUNNING 任务已经把发布请求发出去了，也不会去撤销。
>  调度系统不回滚已发生行为，
>  最终是否发布由文章状态机控制，发布操作是幂等的，所以不会产生错误结果。

------

## 面试收尾一句话（加分）

> 这套设计的核心是：
>  **调度层只负责时间和重试，
>  业务层通过状态机保证最终一致性。**
